# You can override the included template(s) by including variable overrides 
# SAST customization: https://docs.gitlab.com/ee/user/application_security/sast/#customizing-the-sast-settings
# Secret Detection customization: https://docs.gitlab.com/ee/user/application_security/secret_detection/pipeline/#customization
# Dependency Scanning customization: https://docs.gitlab.com/ee/user/application_security/dependency_scanning/#customizing-the-dependency-scanning-settings
# Container Scanning customization: https://docs.gitlab.com/ee/user/application_security/container_scanning/#customizing-the-container-scanning-settings
# Note that environment variables can be set in several places
# See https://docs.gitlab.com/ee/ci/variables/#cicd-variable-precedence
# See https://rafaelmedeiros94.medium.com/using-gitlab-to-deploy-terraform-code-in-azure-1d8c839519ea helping for this pipeline

#Define the name of stages for this pipeline
stages:
  - plan
  - apply
  - destroy

#Get from docker hub the lastest image of Terraform for use it
.init:
  image:
    name: hashicorp/terraform:latest
    entrypoint:
      - /usr/bin/env
      - "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

#Initialize terraform, to download all the packages and modules needed for Terraform to work properly, and this information will be cached in a folder called .terraform inside the agent
  before_script:
    # - cd ${TF_ROOT}
    - env
    - |
      cat > backend.hcl <<EOF
      resource_group_name  = "${TF_AZURE_RG}"
      storage_account_name = "${TF_AZURE_STORAGE_ACCOUNT}"
      container_name       = "${TF_AZURE_CONTAINER}"
      key                  = "${TF_STATE_NAME}-${ENV}"
      EOF
    - terraform init -backend-config=backend.hcl -reconfigure
  cache:
    key: terraform
    paths:
      - .terraform

#Validate if the script is syntactically correct, if all the variables are filled in and so on
#Run terraform plan, and generate the plan file as an artifact to be used by Terraform apply in Terraform apply step
.plan_TF:
  stage: plan
  extends: .init
  script: 
    - terraform validate
    - terraform plan -input=false -var-file="variables.tfvars" --out plan-${ENV}
  artifacts:
    paths:
      - plan-${ENV}


#Apply the configuration using the plan file generated by the previous step, and it needs to be manually triggered by an human
.apply_TF:
  extends: .init
  stage: apply
  script:
    - terraform apply -auto-approve plan-${ENV}
  rules:
  - if: '$CI_COMMIT_BRANCH == "master"'
  - if: '$CI_COMMIT_MESSAGE=~ /destroy infra/'
    when: never
  allow_failure: false
  # dependencies:
  #   - terraform_plan
  # only:
  #   refs:
  #     - master

#Apply the configuration using the plan file generated by the previous step, and it needs to be manually triggered by an human
.destroy_TF:
  extends: .init
  stage: destroy
  script:
    - terraform refresh -input=false -var-file="variables.tfvars"
    - terraform destroy -auto-approve -var-file="variables.tfvars"

  rules:
    - if: '$CI_COMMIT_BRANCH == "master"'
      when: manual
    # - if: '$CI_COMMIT_MESSAGE=~ /destroy infra/ && $CI_COMMIT_BRANCH == "master"'
    #   when: manual
    # - if: '$CI_COMMIT_MESSAGE=~ /destroy infra/ && $CI_COMMIT_TAG== "destroy"'
    # - if: '$CI_COMMIT_MESSAGE!= /destroy infra/ && $CI_COMMIT_TAG!= "destroy"'
    #   when: never
  allow_failure: false
  # dependencies:
  #   - terraform_apply
  # only:
  #   refs:
  #     - master


âœ…plan_staging:
  extends: .plan_TF
  variables:
    ENV: staging

âœ…plan_tech:
  extends: .plan_TF
  variables:
    ENV: tech

ðŸ™‚apply_staging:
  extends: .apply_TF
  variables:
    ENV: staging
  needs:
    - âœ…plan_staging
  
ðŸ¤”apply_tech:
  extends: .apply_TF
  variables:
    ENV: tech
  needs:
    - âœ…plan_tech

ðŸ™†destroy_terraform_staging:
  extends: .destroy_TF
  needs: []
  variables:
    ENV: staging
  when: manual

ðŸ“›destroy_terraform_tech:
  extends: .destroy_TF
  needs: []
  variables:
    ENV: tech
  when: manual
